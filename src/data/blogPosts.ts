export const posts = [
  {
    "id": 8,
    "title": "Building PodSkip: A Dream Eight Years in the Making",
    "date": "Jan 24, 2026",
    "content": "## The Idea That Wouldn't Leave Me Alone\n\nI've wanted to build PodSkip since 2018.\n\nBack then, I was deep into podcasts ‚Äî commuting, working out, doing dishes, whatever. And every single time, without fail, I'd be locked into some fascinating conversation about technology or philosophy or whatever, and then suddenly: \"This episode is brought to you by‚Äî\"\n\nAnd I'd fumble for my phone. Try to hit the 30-second skip. Overshoot. Go back. Undershoot. Miss the first sentence of actual content. Repeat three more times per episode.\n\nIt drove me insane.\n\nI remember thinking: \"There has to be a way to automate this. The ads sound *different*. They have a different cadence, different production quality, different energy. A computer should be able to figure this out.\"\n\nBut in 2018? The tech just wasn't there. Not for a solo developer without a machine learning research team and a massive dataset. Speech-to-text was clunky and expensive. Running inference was slow. The idea went into my mental backlog ‚Äî that graveyard of \"someday\" projects that every developer has.\n\n## Fast Forward to Now\n\nHere's the thing about technology: it moves fast, and sometimes it moves in exactly the direction you were hoping for.\n\nOver the past couple years, AI has gotten absurdly good at transcription. We're talking fast, cheap, and accurate. Cloud APIs can process an hour-long podcast episode in seconds. And large language models have gotten genuinely good at understanding context ‚Äî at recognizing when someone shifts from \"authentic conversation\" to \"reading ad copy.\"\n\nI realized that the project I couldn't build in 2018 was suddenly... buildable.\n\nSo I built it.\n\n## What PodSkip Actually Does\n\nThe core idea is simple: you paste a podcast RSS feed, pick an episode, and hit play. Behind the scenes, PodSkip:\n\n1. Downloads the episode audio\n2. Sends it through a cloud transcription service\n3. Analyzes the transcript to detect ad segments\n4. Marks those timestamps\n5. Automatically mutes the audio when you hit an ad during playback\n\nNo manual skipping. No fumbling for your phone. Just seamless listening.\n\nFor Pro users, you can also download ad-free MP3s ‚Äî the ads get stripped out entirely, and you get a clean file to listen to offline however you want.\n\n## The Vibe-Coding Experience\n\nI'm going to be real with you: I vibe-coded a lot of this with Claude Code.\n\nIf you're not familiar with the term, \"vibe-coding\" is basically when you describe what you want to build in natural language and let an AI help you write the code. You iterate fast, you don't get bogged down in boilerplate, and you can focus on the actual product instead of fighting with syntax.\n\nWas it a perfectly architected codebase from day one? Absolutely not. Did I ship something that works and that people can actually use? Yes.\n\nI've spent a lot of my career worrying about whether I'm a \"real\" programmer, whether I understand things deeply enough, whether I'm relying too much on tools and abstractions. And honestly? Building PodSkip helped me let go of some of that. The goal was never to prove I could write everything from scratch. The goal was to make something useful. Claude Code helped me do that faster than I ever could have alone.\n\nThe future of software development is collaborative ‚Äî humans and AI working together. I'm here for it.\n\n## The Challenges (Because Of Course There Were Challenges)\n\nThis project wasn't just smooth sailing. A few things that made me want to throw my laptop out the window:\n\n**Pre-roll ads are sneaky.** Some podcasts start with an ad before any content. Detecting those required different logic because there's no \"transition\" to detect ‚Äî you're just dropped straight into an ad read.\n\n**Dynamic ad insertion is a thing.** A lot of podcasts now have ads that are inserted dynamically, which means the same episode might have different ads depending on when and where you download it. The timestamps can shift. The ads can change. It's chaos.\n\n**Accuracy is hard.** Getting to 94% accuracy sounds good until you realize that 6% of the time, you're either muting real content or letting ads through. Both feel bad. I spent a lot of time tuning the detection to minimize false positives while still catching the sneaky ads.\n\n**Audio processing is its own beast.** Dealing with different bitrates, formats, encoding issues, and making sure the web player handles everything smoothly ‚Äî that's a whole skill set I had to level up on.\n\nBut that's the fun part, right? Solving problems you've never solved before. Learning things you didn't know you needed to learn.\n\n## Why This Matters to Me\n\nI've always believed that AI should make people's lives easier in tangible, everyday ways.\n\nNot just \"AI will revolutionize industries\" in some abstract sense. I mean: AI should save you from the small annoyances. The friction. The tedious stuff that adds up over time.\n\nMuting podcast ads isn't going to change the world. But it might make your commute a little better. It might let you stay in flow during a workout. It might give you back a few minutes of your day that would otherwise be spent fumbling with skip buttons.\n\nThat's the kind of AI application I care about. Practical. Human-centered. Actually useful.\n\nAnd honestly? I'm just super gassed that current technology makes this possible. Six years ago, this was a pipe dream. Now it's a real thing that real people can use. That feels incredible.\n\n## What's Next\n\nPodSkip works for audio podcasts right now, but I'm already thinking about what's next:\n\n**Video podcasts.** YouTube, Spotify video, all of that. The same fundamental problem exists ‚Äî ads interrupting content ‚Äî and the same solution should apply. Detect the ad segments, skip or mute them, let people watch in peace.\n\n**Videos in general.** Why stop at podcasts? Long-form YouTube content, lectures, conference talks ‚Äî anything with mid-roll ads could benefit from this kind of automatic detection.\n\nI'm not sure exactly what the roadmap looks like yet, but the foundation is there. The hard part ‚Äî accurate ad detection ‚Äî is solved (or at least solved enough). Extending it to new formats is mostly an engineering problem.\n\n## Try It Out\n\nIf you're a podcast listener who's ever been annoyed by ads, I'd love for you to give PodSkip a try.\n\nThe free tier gives you 3 episodes per month ‚Äî enough to see if it works for the shows you listen to. If you like it, Pro is $4.99/month for 30 episodes plus the ad-free MP3 downloads.\n\n**[podskip.lol](https://podskip.lol)**\n\nAnd if you have feedback ‚Äî things that don't work, features you want, ads that got missed ‚Äî I genuinely want to hear it. This is a passion project, and I'm building it for people like me who just want to enjoy their podcasts without interruption.\n\nThanks for reading. And thanks for letting me share something I've wanted to build for a really, really long time.\n\n‚Äî Zach (& Claude)"
  },
  {
    "id": 7,
    "title": "How I Built a Discord Bot That Lets Me Manage My Mac Files From My Phone",
    "date": "Jan 16, 2026",
    "content": "# How I Built a Discord Bot That Lets Me Manage My Mac Files From My Phone\n\nEver been lying in bed, phone in hand, and thought \"I really wish I could create a quick note on my Desktop right now\"? Or maybe you're out and about and need to check if you saved that important file before a meeting?\n\nI built a Discord bot that lets me do exactly that ‚Äî read, write, and manage files on my Mac's Desktop folder, all through Discord on my phone. And the best part? It's powered by Claude AI, so I can just talk to it naturally.\n\nIn this post, I'll walk you through how to build one yourself.\n\n## What We're Building\n\nHere's the basic architecture:\n\n\\`\\`\\`\nYour Phone ‚Üí Discord ‚Üí Discord Bot ‚Üí Claude API ‚Üí MCP Server ‚Üí Mac Files\n\\`\\`\\`\n\nThe bot uses Anthropic's Model Context Protocol (MCP) to give Claude access to your file system in a controlled way. When you send a message like \"create a file called todo.txt with my grocery list,\" Claude figures out what tools to use and executes them through the MCP server running on your Mac.\n\n## What You Can Do With It\n\nOnce it's set up, you can send messages like:\n\n- \"What files are on my Desktop?\"\n- \"Read the contents of notes.md\"\n- \"Create a file called ideas.txt with some project brainstorming\"\n- \"Make a new folder called Projects\"\n- \"How big is that presentation.pdf?\"\n- \"Delete old-draft.txt\"\n\nClaude interprets your request and handles the file operations automatically.\n\n## Prerequisites\n\nBefore we start, you'll need:\n\n- **Node.js v18+** installed on your Mac\n- An **Anthropic API key** from [console.anthropic.com](https://console.anthropic.com)\n- A **Discord account**\n\n## Step 1: Create Your Discord Bot\n\nFirst, we need to create a bot in Discord's developer portal.\n\n1. Go to [discord.com/developers/applications](https://discord.com/developers/applications)\n2. Click **\"New Application\"** and give it a name (I called mine \"ClaudeFiles\")\n3. Go to the **\"Bot\"** tab in the left sidebar\n4. Click **\"Reset Token\"** and copy the token somewhere safe ‚Äî you'll only see it once!\n5. Scroll down to **\"Privileged Gateway Intents\"** and enable **Message Content Intent**\n6. Save your changes\n\nNow generate an invite link:\n\n1. Go to **\"OAuth2\" ‚Üí \"URL Generator\"**\n2. Under Scopes, select \\`bot\\`\n3. Under Bot Permissions, select \\`Send Messages\\` and \\`Read Message History\\`\n4. Copy the generated URL and open it to add the bot to your server\n\n## Step 2: Get Your Discord User ID\n\nFor security, we'll restrict the bot to only respond to you.\n\n1. In Discord, go to Settings ‚Üí Advanced ‚Üí Enable **Developer Mode**\n2. Right-click your username anywhere in Discord\n3. Click **\"Copy User ID\"**\n\nSave this number for later.\n\n## Step 3: Set Up the Project\n\nCreate a new directory and initialize the project:\n\n\\`\\`\\`bash\nmkdir discord-file-bot\ncd discord-file-bot\nnpm init -y\n\\`\\`\\`\n\nInstall the dependencies:\n\n\\`\\`\\`bash\nnpm install discord.js @anthropic-ai/sdk @modelcontextprotocol/sdk dotenv\n\\`\\`\\`\n\nUpdate your \\`package.json\\` to use ES modules:\n\n\\`\\`\\`json\n{\n  \"name\": \"discord-file-bot\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"start\": \"node discord-bot/index.js\"\n  },\n  \"dependencies\": {\n    \"@anthropic-ai/sdk\": \"^0.52.0\",\n    \"@modelcontextprotocol/sdk\": \"^1.0.0\",\n    \"discord.js\": \"^14.14.1\",\n    \"dotenv\": \"^16.3.1\"\n  }\n}\n\\`\\`\\`\n\nCreate your \\`.env\\` file:\n\n\\`\\`\\`bash\nDISCORD_TOKEN=your_discord_bot_token\nANTHROPIC_API_KEY=your_anthropic_api_key\nDISCORD_USER_ID=your_discord_user_id\n\\`\\`\\`\n\n## Step 4: Build the MCP Server\n\nThe MCP server is what gives Claude controlled access to your file system. Create \\`mcp-server/index.js\\`:\n\n\\`\\`\\`javascript\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n  ListToolsResultSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport fs from \"fs/promises\";\nimport path from \"path\";\nimport os from \"os\";\n\n// Restrict all operations to Desktop folder only\nconst DESKTOP_PATH = path.join(os.homedir(), \"Desktop\");\n\n// Security: Ensure path is within Desktop\nfunction validatePath(filePath) {\n  const resolved = path.resolve(DESKTOP_PATH, filePath);\n  if (!resolved.startsWith(DESKTOP_PATH)) {\n    throw new Error(\"Access denied: Path must be within Desktop folder\");\n  }\n  return resolved;\n}\n\nconst server = new Server(\n  {\n    name: \"desktop-file-server\",\n    version: \"1.0.0\",\n  },\n  {\n    capabilities: {\n      tools: {},\n    },\n  }\n);\n\n// Define available tools\nserver.setRequestHandler(ListToolsRequestSchema, async () => {\n  return {\n    tools: [\n      {\n        name: \"read_file\",\n        description: \"Read the contents of a file from the Desktop folder\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            filename: {\n              type: \"string\",\n              description: \"The name of the file to read (relative to Desktop)\",\n            },\n          },\n          required: [\"filename\"],\n        },\n      },\n      {\n        name: \"write_file\",\n        description: \"Write content to a file on the Desktop folder\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            filename: {\n              type: \"string\",\n              description: \"The name of the file to write (relative to Desktop)\",\n            },\n            content: {\n              type: \"string\",\n              description: \"The content to write to the file\",\n            },\n          },\n          required: [\"filename\", \"content\"],\n        },\n      },\n      {\n        name: \"list_files\",\n        description: \"List all files and folders on the Desktop\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            subfolder: {\n              type: \"string\",\n              description: \"Optional subfolder within Desktop to list\",\n            },\n          },\n        },\n      },\n      {\n        name: \"delete_file\",\n        description: \"Delete a file from the Desktop folder\",\n        inputSchema: {\n          type: \"object\",\n          properties: {\n            filename: {\n              type: \"string\",\n              description: \"The name of the file to delete (relative to Desktop)\",\n            },\n          },\n          required: [\"filename\"],\n        },\n      },\n    ],\n  };\n});\n\n// Handle tool calls\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  const { name, arguments: args } = request.params;\n\n  try {\n    switch (name) {\n      case \"read_file\": {\n        const filePath = validatePath(args.filename);\n        const content = await fs.readFile(filePath, \"utf-8\");\n        return { content: [{ type: \"text\", text: content }] };\n      }\n\n      case \"write_file\": {\n        const filePath = validatePath(args.filename);\n        await fs.mkdir(path.dirname(filePath), { recursive: true });\n        await fs.writeFile(filePath, args.content, \"utf-8\");\n        return { content: [{ type: \"text\", text: \\`Wrote to \\${args.filename}\\` }] };\n      }\n\n      case \"list_files\": {\n        const targetPath = args.subfolder \n          ? validatePath(args.subfolder) \n          : DESKTOP_PATH;\n        const entries = await fs.readdir(targetPath, { withFileTypes: true });\n        const fileList = entries.map((entry) => ({\n          name: entry.name,\n          type: entry.isDirectory() ? \"folder\" : \"file\",\n        }));\n        return { content: [{ type: \"text\", text: JSON.stringify(fileList, null, 2) }] };\n      }\n\n      case \"delete_file\": {\n        const filePath = validatePath(args.filename);\n        await fs.unlink(filePath);\n        return { content: [{ type: \"text\", text: \\`Deleted \\${args.filename}\\` }] };\n      }\n\n      default:\n        throw new Error(\\`Unknown tool: \\${name}\\`);\n    }\n  } catch (error) {\n    return { content: [{ type: \"text\", text: \\`Error: \\${error.message}\\` }], isError: true };\n  }\n});\n\n// Start the server\nconst transport = new StdioServerTransport();\nawait server.connect(transport);\nconsole.error(\"Desktop File MCP Server running on stdio\");\n\\`\\`\\`\n\nThe key security feature here is the \\`validatePath\\` function ‚Äî it ensures that no matter what input comes in, the bot can only access files within your Desktop folder.\n\n## Step 5: Build the Discord Bot\n\nNow for the main bot that ties everything together. Create \\`discord-bot/index.js\\`:\n\n\\`\\`\\`javascript\nimport { Client, GatewayIntentBits, Partials } from \"discord.js\";\nimport Anthropic from \"@anthropic-ai/sdk\";\nimport { spawn } from \"child_process\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport dotenv from \"dotenv\";\n\ndotenv.config();\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\nconst DISCORD_TOKEN = process.env.DISCORD_TOKEN;\nconst ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;\nconst ALLOWED_USER_ID = process.env.DISCORD_USER_ID;\n\n// Initialize Discord client\nconst discord = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.DirectMessages,\n    GatewayIntentBits.MessageContent,\n  ],\n  partials: [Partials.Channel, Partials.Message],\n});\n\nconst anthropic = new Anthropic({ apiKey: ANTHROPIC_API_KEY });\n\n// MCP Server management\nlet mcpProcess = null;\nlet pendingRequests = new Map();\nlet requestId = 0;\n\nfunction startMcpServer() {\n  const mcpPath = path.join(__dirname, \"..\", \"mcp-server\", \"index.js\");\n  mcpProcess = spawn(\"node\", [mcpPath], { stdio: [\"pipe\", \"pipe\", \"pipe\"] });\n\n  let buffer = \"\";\n  mcpProcess.stdout.on(\"data\", (data) => {\n    buffer += data.toString();\n    const lines = buffer.split(\"\\n\");\n    buffer = lines.pop() || \"\";\n    \n    for (const line of lines) {\n      if (line.trim()) {\n        try {\n          const response = JSON.parse(line);\n          if (response.id && pendingRequests.has(response.id)) {\n            pendingRequests.get(response.id).resolve(response);\n            pendingRequests.delete(response.id);\n          }\n        } catch (e) { /* Not JSON */ }\n      }\n    }\n  });\n\n  mcpProcess.stderr.on(\"data\", (data) => {\n    console.log(\"MCP Server:\", data.toString().trim());\n    if (data.toString().includes(\"running\")) {\n      initializeMcp();\n    }\n  });\n}\n\nasync function sendMcpRequest(method, params = {}) {\n  return new Promise((resolve, reject) => {\n    const id = ++requestId;\n    pendingRequests.set(id, { resolve, reject });\n    mcpProcess.stdin.write(JSON.stringify({ jsonrpc: \"2.0\", id, method, params }) + \"\\n\");\n    setTimeout(() => {\n      if (pendingRequests.has(id)) {\n        pendingRequests.delete(id);\n        reject(new Error(\"Timeout\"));\n      }\n    }, 30000);\n  });\n}\n\nasync function initializeMcp() {\n  await sendMcpRequest(\"initialize\", {\n    protocolVersion: \"2024-11-05\",\n    capabilities: {},\n    clientInfo: { name: \"discord-bot\", version: \"1.0.0\" },\n  });\n  await sendMcpRequest(\"notifications/initialized\", {});\n  console.log(\"MCP Server initialized\");\n}\n\n// Define tools for Claude\nconst tools = [\n  {\n    name: \"read_file\",\n    description: \"Read the contents of a file from the Desktop folder\",\n    input_schema: {\n      type: \"object\",\n      properties: {\n        filename: { type: \"string\", description: \"The file to read\" },\n      },\n      required: [\"filename\"],\n    },\n  },\n  {\n    name: \"write_file\",\n    description: \"Write content to a file on the Desktop folder\",\n    input_schema: {\n      type: \"object\",\n      properties: {\n        filename: { type: \"string\", description: \"The file to write\" },\n        content: { type: \"string\", description: \"The content to write\" },\n      },\n      required: [\"filename\", \"content\"],\n    },\n  },\n  {\n    name: \"list_files\",\n    description: \"List all files and folders on the Desktop\",\n    input_schema: {\n      type: \"object\",\n      properties: {\n        subfolder: { type: \"string\", description: \"Optional subfolder to list\" },\n      },\n    },\n  },\n  {\n    name: \"delete_file\",\n    description: \"Delete a file from the Desktop folder\",\n    input_schema: {\n      type: \"object\",\n      properties: {\n        filename: { type: \"string\", description: \"The file to delete\" },\n      },\n      required: [\"filename\"],\n    },\n  },\n];\n\nasync function executeTool(toolName, toolInput) {\n  const response = await sendMcpRequest(\"tools/call\", { name: toolName, arguments: toolInput });\n  return response.result?.content?.[0]?.text || JSON.stringify(response.result);\n}\n\nasync function processWithClaude(userMessage) {\n  const messages = [{ role: \"user\", content: userMessage }];\n  const systemPrompt = \\`You are a helpful assistant that manages files on the user's Mac Desktop. Keep responses concise for mobile reading.\\`;\n\n  let response = await anthropic.messages.create({\n    model: \"claude-sonnet-4-20250514\",\n    max_tokens: 1024,\n    system: systemPrompt,\n    tools,\n    messages,\n  });\n\n  // Handle tool use loop\n  while (response.stop_reason === \"tool_use\") {\n    const toolUseBlocks = response.content.filter((b) => b.type === \"tool_use\");\n    const toolResults = [];\n    \n    for (const toolUse of toolUseBlocks) {\n      const result = await executeTool(toolUse.name, toolUse.input);\n      toolResults.push({ type: \"tool_result\", tool_use_id: toolUse.id, content: result });\n    }\n\n    messages.push({ role: \"assistant\", content: response.content });\n    messages.push({ role: \"user\", content: toolResults });\n\n    response = await anthropic.messages.create({\n      model: \"claude-sonnet-4-20250514\",\n      max_tokens: 1024,\n      system: systemPrompt,\n      tools,\n      messages,\n    });\n  }\n\n  const textBlocks = response.content.filter((b) => b.type === \"text\");\n  return textBlocks.map((b) => b.text).join(\"\\n\") || \"Done!\";\n}\n\n// Discord event handlers\ndiscord.on(\"ready\", () => {\n  console.log(\\`Logged in as \\${discord.user.tag}\\`);\n});\n\ndiscord.on(\"messageCreate\", async (message) => {\n  if (message.author.bot) return;\n  if (ALLOWED_USER_ID && message.author.id !== ALLOWED_USER_ID) {\n    console.log(\\`Ignored message from unauthorized user: \\${message.author.tag}\\`);\n    return;\n  }\n\n  const isDM = !message.guild;\n  const isMentioned = message.mentions.has(discord.user);\n  if (!isDM && !isMentioned) return;\n\n  let content = message.content.replace(new RegExp(\\`<@!?\\${discord.user.id}>\\`, \"g\"), \"\").trim();\n  if (!content) {\n    await message.reply(\"Hi! How can I help with your Desktop files?\");\n    return;\n  }\n\n  await message.channel.sendTyping();\n  const response = await processWithClaude(content);\n  await message.reply(response.slice(0, 2000)); // Discord's character limit\n});\n\n// Start everything\nconsole.log(\"Starting MCP server...\");\nstartMcpServer();\nconsole.log(\"Logging into Discord...\");\ndiscord.login(DISCORD_TOKEN);\n\\`\\`\\`\n\n## Step 6: Run It\n\nStart the bot:\n\n\\`\\`\\`bash\nnpm start\n\\`\\`\\`\n\nYou should see:\n\n\\`\\`\\`\nStarting MCP server...\nLogging into Discord...\nMCP Server: Desktop File MCP Server running on stdio\nMCP Server initialized\nLogged in as YourBot#1234\n\\`\\`\\`\n\nNow open Discord on your phone, DM your bot, and try:\n\n\\`\\`\\`\nWhat's on my Desktop?\n\\`\\`\\`\n\n## Keeping It Running\n\nIf you want the bot to run continuously (even after closing the terminal), I recommend using PM2:\n\n\\`\\`\\`bash\nnpm install -g pm2\npm2 start npm --name \"discord-file-bot\" -- start\npm2 save\npm2 startup  # Sets up auto-start on reboot\n\\`\\`\\`\n\n## Security Considerations\n\nA few things to keep in mind:\n\n1. **Desktop-only access**: The MCP server validates all paths to ensure they stay within \\`~/Desktop\\`\n2. **Single-user lock**: The bot only responds to your Discord user ID\n3. **Local only**: The MCP server runs locally on your Mac ‚Äî your files never leave your machine except through your requests\n4. **API keys**: Keep your \\`.env\\` file private and never commit it to git\n\n## Extending the Bot\n\nSome ideas for taking this further:\n\n- Add more folders (Documents, Downloads, etc.) with separate permissions\n- Add file search functionality\n- Support for reading PDFs or other document types\n- Voice memos that get transcribed and saved as notes\n- Integration with other MCP servers (calendar, email, etc.)\n\n## Wrapping Up\n\nWhat I love about this setup is how natural it feels. I don't have to remember specific commands ‚Äî I just tell Claude what I want in plain English, and it figures out the right tools to use. MCP makes it easy to give Claude controlled access to local resources without compromising security.\n\nThe full source code is available on my GitHub if you want to grab it and customize it for your own use.\n\nHappy building!"
  },
  {
    "id": 6,
    "title": "How I Built an MCP Server to Let Claude Control My Mac",
    "date": "Jan 16, 2026",
    "content": "# How I Built an MCP Server to Let Claude Control My Mac\n\n*Give your AI assistant superpowers on macOS ‚Äî opening apps, closing windows, and managing your desktop with simple conversation.*\n\n---\n\nI've been using Claude as my daily AI assistant for a while now, and it's great for answering questions, writing code, and brainstorming ideas. But I kept running into a frustrating limitation: Claude couldn't actually *do* anything on my computer.\n\n\"Open Slack for me\" ‚Üí Sorry, I can't do that.\n\"Close all these windows\" ‚Üí I don't have access to your system.\n\nThat changed when I discovered the **Model Context Protocol (MCP)** ‚Äî an open standard that lets you extend Claude's capabilities with custom tools. Within an afternoon, I had Claude opening apps, closing windows, and managing my desktop like a proper assistant.\n\nHere's how I built it, and how you can too.\n\n---\n\n## What is MCP?\n\nMCP (Model Context Protocol) is a way to give Claude access to external tools and data sources. Think of it like building a bridge between Claude's brain and your computer's capabilities.\n\nYou create a small server that exposes \"tools\" ‚Äî functions that Claude can call when needed. When you ask Claude to open an app, it recognizes the intent, calls your tool, and the magic happens.\n\nThe best part? It's surprisingly simple to set up.\n\n---\n\n## What We're Building\n\nBy the end of this guide, you'll have an MCP server that lets Claude:\n\n- **Open any application** on your Mac\n- **Close apps** individually or all at once\n- **Open files** with specific applications\n- **Launch URLs** in your preferred browser\n- **List running and installed apps**\n\nAll through natural conversation. Just ask Claude, and it happens.\n\n---\n\n## Prerequisites\n\nBefore we dive in, make sure you have:\n\n- **macOS** (I tested on Ventura and Sonoma)\n- **Node.js 18+** ‚Äî Check with \\`node --version\\`\n- **Claude Desktop** ‚Äî Download from [claude.ai/download](https://claude.ai/download)\n\nNeed Node.js? Install it via Homebrew:\n\n\\`\\`\\`bash\nbrew install node\n\\`\\`\\`\n\n---\n\n## Step 1: Set Up the Project\n\nLet's create our project structure. Open Terminal and run:\n\n\\`\\`\\`bash\n# Create and enter the project directory\nmkdir ~/mac-control-mcp\ncd ~/mac-control-mcp\n\n# Initialize the project\nnpm init -y\n\n# Install dependencies\nnpm install @modelcontextprotocol/sdk\nnpm install -D typescript @types/node\n\\`\\`\\`\n\nThe MCP SDK handles all the protocol communication ‚Äî we just need to define our tools and implement them.\n\n---\n\n## Step 2: Configure TypeScript\n\nCreate a \\`tsconfig.json\\` file in your project root:\n\n\\`\\`\\`json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n\\`\\`\\`\n\n---\n\n## Step 3: Update package.json\n\nReplace your \\`package.json\\` contents with:\n\n\\`\\`\\`json\n{\n  \"name\": \"mac-control-mcp\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/index.js\",\n    \"dev\": \"tsc && node dist/index.js\"\n  },\n  \"dependencies\": {\n    \"@modelcontextprotocol/sdk\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"typescript\": \"^5.0.0\"\n  }\n}\n\\`\\`\\`\n\n---\n\n## Step 4: Write the Server\n\nNow for the fun part. Create the source directory and main file:\n\n\\`\\`\\`bash\nmkdir src\ntouch src/index.ts\n\\`\\`\\`\n\nOpen \\`src/index.ts\\` in your editor and add the following code. I've broken it into sections so you can understand what each part does.\n\n### The Foundation\n\nFirst, we set up imports and initialize the server:\n\n\\`\\`\\`typescript\nimport { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { exec } from \"child_process\";\nimport { promisify } from \"util\";\n\nconst execAsync = promisify(exec);\n\nconst server = new Server(\n  { name: \"mac-control\", version: \"1.0.0\" },\n  { capabilities: { tools: {} } }\n);\n\\`\\`\\`\n\n### Defining the Tools\n\nNext, we tell Claude what tools are available. This is like creating a menu of capabilities:\n\n\\`\\`\\`typescript\nserver.setRequestHandler(ListToolsRequestSchema, async () => ({\n  tools: [\n    // --- Close Tools ---\n    {\n      name: \"close_all_apps\",\n      description: \"Closes all open applications except Finder and essential system apps\",\n      inputSchema: {\n        type: \"object\",\n        properties: {\n          exclude: {\n            type: \"array\",\n            items: { type: \"string\" },\n            description: \"App names to keep open (e.g., ['Terminal', 'Claude'])\"\n          },\n          force: {\n            type: \"boolean\",\n            description: \"Force quit apps (may lose unsaved work)\",\n            default: false\n          }\n        }\n      }\n    },\n    {\n      name: \"close_app\",\n      description: \"Close a specific application by name\",\n      inputSchema: {\n        type: \"object\",\n        properties: {\n          appName: { type: \"string\", description: \"Name of the app to close\" },\n          force: { type: \"boolean\", default: false }\n        },\n        required: [\"appName\"]\n      }\n    },\n\n    // --- Open Tools ---\n    {\n      name: \"open_app\",\n      description: \"Open/launch a specific application by name\",\n      inputSchema: {\n        type: \"object\",\n        properties: {\n          appName: { \n            type: \"string\", \n            description: \"Name of the app to open (e.g., 'Safari', 'Visual Studio Code')\" \n          },\n          newInstance: {\n            type: \"boolean\",\n            description: \"Open a new instance even if already running\",\n            default: false\n          },\n          hide: {\n            type: \"boolean\",\n            description: \"Open the app hidden/in background\",\n            default: false\n          }\n        },\n        required: [\"appName\"]\n      }\n    },\n    {\n      name: \"open_apps\",\n      description: \"Open multiple applications at once\",\n      inputSchema: {\n        type: \"object\",\n        properties: {\n          appNames: {\n            type: \"array\",\n            items: { type: \"string\" },\n            description: \"List of app names to open\"\n          }\n        },\n        required: [\"appNames\"]\n      }\n    },\n    {\n      name: \"open_app_with_file\",\n      description: \"Open a file with a specific application\",\n      inputSchema: {\n        type: \"object\",\n        properties: {\n          appName: { type: \"string\", description: \"Name of the app\" },\n          filePath: { type: \"string\", description: \"Path to the file to open\" }\n        },\n        required: [\"appName\", \"filePath\"]\n      }\n    },\n    {\n      name: \"open_url\",\n      description: \"Open a URL in a specific browser or the default browser\",\n      inputSchema: {\n        type: \"object\",\n        properties: {\n          url: { type: \"string\", description: \"URL to open\" },\n          browser: { \n            type: \"string\", \n            description: \"Browser to use (e.g., 'Safari', 'Google Chrome'). Leave empty for default.\" \n          }\n        },\n        required: [\"url\"]\n      }\n    },\n\n    // --- List/Info Tools ---\n    {\n      name: \"list_open_apps\",\n      description: \"Lists all currently running applications\",\n      inputSchema: { type: \"object\", properties: {} }\n    },\n    {\n      name: \"list_installed_apps\",\n      description: \"Lists all applications installed on this Mac\",\n      inputSchema: {\n        type: \"object\",\n        properties: {\n          searchTerm: {\n            type: \"string\",\n            description: \"Optional: filter apps by name (case-insensitive)\"\n          }\n        }\n      }\n    },\n    {\n      name: \"is_app_running\",\n      description: \"Check if a specific application is currently running\",\n      inputSchema: {\n        type: \"object\",\n        properties: {\n          appName: { type: \"string\", description: \"Name of the app to check\" }\n        },\n        required: [\"appName\"]\n      }\n    }\n  ]\n}));\n\\`\\`\\`\n\n### Implementing the Tools\n\nNow we write the actual logic. This is where AppleScript and shell commands do the heavy lifting:\n\n\\`\\`\\`typescript\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  const { name, arguments: args } = request.params;\n\n  switch (name) {\n    // -------------------------------------------------------------------------\n    // LIST / INFO TOOLS\n    // -------------------------------------------------------------------------\n    \n    case \"list_open_apps\": {\n      const script = \\`\n        tell application \"System Events\"\n          set appList to name of every process whose background only is false\n        end tell\n        return appList\n      \\`;\n      const { stdout } = await execAsync(\\`osascript -e '\\${script}'\\`);\n      const apps = stdout.trim().split(\", \");\n      return { content: [{ type: \"text\", text: JSON.stringify(apps, null, 2) }] };\n    }\n\n    case \"list_installed_apps\": {\n      const { searchTerm } = args as { searchTerm?: string };\n      \n      const { stdout } = await execAsync(\\`\n        find /Applications ~/Applications -maxdepth 2 -name \"*.app\" 2>/dev/null | \n        sed 's|.*/||' | \n        sed 's|.app$||' | \n        sort -u\n      \\`);\n      \n      let apps = stdout.trim().split(\"\\\\n\").filter(Boolean);\n      \n      if (searchTerm) {\n        const term = searchTerm.toLowerCase();\n        apps = apps.filter(app => app.toLowerCase().includes(term));\n      }\n      \n      return { content: [{ type: \"text\", text: JSON.stringify(apps, null, 2) }] };\n    }\n\n    case \"is_app_running\": {\n      const { appName } = args as { appName: string };\n      const script = \\`\n        tell application \"System Events\"\n          set isRunning to (name of processes) contains \"\\${appName}\"\n        end tell\n        return isRunning\n      \\`;\n      const { stdout } = await execAsync(\\`osascript -e '\\${script}'\\`);\n      const isRunning = stdout.trim() === \"true\";\n      return { \n        content: [{ \n          type: \"text\", \n          text: JSON.stringify({ appName, isRunning }, null, 2) \n        }] \n      };\n    }\n\n    // -------------------------------------------------------------------------\n    // OPEN TOOLS\n    // -------------------------------------------------------------------------\n    \n    case \"open_app\": {\n      const { appName, newInstance = false, hide = false } = args as { \n        appName: string; \n        newInstance?: boolean;\n        hide?: boolean;\n      };\n      \n      try {\n        let command = \\`open -a \"\\${appName}\"\\`;\n        if (newInstance) command += \" -n\";\n        if (hide) command += \" -g\";\n        \n        await execAsync(command);\n        \n        if (!hide) {\n          const activateScript = \\`tell application \"\\${appName}\" to activate\\`;\n          await execAsync(\\`osascript -e '\\${activateScript}'\\`);\n        }\n        \n        return { \n          content: [{ \n            type: \"text\", \n            text: \\`Opened \\${appName}\\${hide ? \" (in background)\" : \"\"}\\` \n          }] \n        };\n      } catch (error) {\n        return { \n          content: [{ \n            type: \"text\", \n            text: \\`Failed to open \\${appName}: \\${error}. Use list_installed_apps to see available apps.\\` \n          }] \n        };\n      }\n    }\n\n    case \"open_apps\": {\n      const { appNames } = args as { appNames: string[] };\n      const results: { opened: string[]; failed: string[] } = { opened: [], failed: [] };\n      \n      for (const appName of appNames) {\n        try {\n          await execAsync(\\`open -a \"\\${appName}\"\\`);\n          results.opened.push(appName);\n        } catch {\n          results.failed.push(appName);\n        }\n      }\n      \n      return { content: [{ type: \"text\", text: JSON.stringify(results, null, 2) }] };\n    }\n\n    case \"open_app_with_file\": {\n      const { appName, filePath } = args as { appName: string; filePath: string };\n      \n      try {\n        await execAsync(\\`open -a \"\\${appName}\" \"\\${filePath}\"\\`);\n        return { \n          content: [{ \n            type: \"text\", \n            text: \\`Opened \"\\${filePath}\" with \\${appName}\\` \n          }] \n        };\n      } catch (error) {\n        return { \n          content: [{ \n            type: \"text\", \n            text: \\`Failed to open file: \\${error}\\` \n          }] \n        };\n      }\n    }\n\n    case \"open_url\": {\n      const { url, browser } = args as { url: string; browser?: string };\n      \n      try {\n        const command = browser \n          ? \\`open -a \"\\${browser}\" \"\\${url}\"\\`\n          : \\`open \"\\${url}\"\\`;\n        \n        await execAsync(command);\n        return { \n          content: [{ \n            type: \"text\", \n            text: \\`Opened \\${url}\\${browser ? \\` in \\${browser}\\` : \" in default browser\"}\\` \n          }] \n        };\n      } catch (error) {\n        return { \n          content: [{ \n            type: \"text\", \n            text: \\`Failed to open URL: \\${error}\\` \n          }] \n        };\n      }\n    }\n\n    // -------------------------------------------------------------------------\n    // CLOSE TOOLS\n    // -------------------------------------------------------------------------\n    \n    case \"close_app\": {\n      const { appName, force = false } = args as { appName: string; force?: boolean };\n      const action = force ? \"quit\" : \"quit saving yes\";\n      const script = \\`\n        tell application \"\\${appName}\"\n          \\${action}\n        end tell\n      \\`;\n      try {\n        await execAsync(\\`osascript -e '\\${script}'\\`);\n        return { content: [{ type: \"text\", text: \\`Closed \\${appName}\\` }] };\n      } catch (error) {\n        return { content: [{ type: \"text\", text: \\`Failed to close \\${appName}: \\${error}\\` }] };\n      }\n    }\n\n    case \"close_all_apps\": {\n      const { exclude = [], force = false } = args as { exclude?: string[]; force?: boolean };\n      \n      const protected_apps = [\"Finder\", \"System Preferences\", \"System Settings\", ...exclude];\n      \n      const script = \\`\n        tell application \"System Events\"\n          set appList to name of every process whose background only is false\n        end tell\n        return appList\n      \\`;\n      \n      const { stdout } = await execAsync(\\`osascript -e '\\${script}'\\`);\n      const apps = stdout.trim().split(\", \");\n      \n      const closed: string[] = [];\n      const skipped: string[] = [];\n      const failed: string[] = [];\n\n      for (const app of apps) {\n        if (protected_apps.some(p => app.toLowerCase().includes(p.toLowerCase()))) {\n          skipped.push(app);\n          continue;\n        }\n        \n        try {\n          const action = force ? \"quit\" : \"quit saving yes\";\n          const quitScript = \\`tell application \"\\${app}\" to \\${action}\\`;\n          await execAsync(\\`osascript -e '\\${quitScript}'\\`);\n          closed.push(app);\n        } catch {\n          failed.push(app);\n        }\n      }\n\n      return {\n        content: [{\n          type: \"text\",\n          text: JSON.stringify({ closed, skipped, failed }, null, 2)\n        }]\n      };\n    }\n\n    default:\n      throw new Error(\\`Unknown tool: \\${name}\\`);\n  }\n});\n\\`\\`\\`\n\n### Starting the Server\n\nFinally, we connect the server to stdio transport (how Claude Desktop communicates with MCP servers):\n\n\\`\\`\\`typescript\nconst transport = new StdioServerTransport();\nserver.connect(transport);\nconsole.error(\"Mac Control MCP server running\");\n\\`\\`\\`\n\n---\n\n## Step 5: Build It\n\nCompile the TypeScript:\n\n\\`\\`\\`bash\nnpm run build\n\\`\\`\\`\n\nYou should see a \\`dist\\` folder appear with the compiled JavaScript.\n\n---\n\n## Step 6: Connect to Claude Desktop\n\nNow we need to tell Claude Desktop about our server. Create or edit the config file:\n\n\\`\\`\\`bash\nmkdir -p ~/Library/Application\\\\ Support/Claude\n\\`\\`\\`\n\nOpen \\`~/Library/Application Support/Claude/claude_desktop_config.json\\` and add:\n\n\\`\\`\\`json\n{\n  \"mcpServers\": {\n    \"mac-control\": {\n      \"command\": \"node\",\n      \"args\": [\"/Users/YOUR_USERNAME/mac-control-mcp/dist/index.js\"]\n    }\n  }\n}\n\\`\\`\\`\n\n**Important:** Replace \\`YOUR_USERNAME\\` with your actual username. Find it by running \\`whoami\\` in Terminal.\n\n---\n\n## Step 7: Grant Permissions\n\nmacOS takes security seriously. The first time Claude tries to control an app, you'll see permission prompts.\n\nGo to **System Settings ‚Üí Privacy & Security ‚Üí Automation** and allow access when prompted. You may also need to grant **Accessibility** permissions.\n\n---\n\n## Step 8: Restart and Test\n\nQuit Claude Desktop completely (Cmd+Q) and reopen it.\n\nNow try some commands:\n\n> \"What apps do I have running?\"\n\n> \"Open Safari and Slack\"\n\n> \"Close everything except Terminal and Claude\"\n\n> \"Open my Downloads folder in Finder\"\n\n> \"Launch github.com in Chrome\"\n\nIt just works. ‚ú®\n\n---\n\n## How It All Fits Together\n\nHere's what happens when you ask Claude to open an app:\n\n1. You type \"Open Spotify\" in Claude Desktop\n2. Claude recognizes this matches the \\`open_app\\` tool\n3. Claude calls your MCP server with \\`{ appName: \"Spotify\" }\\`\n4. Your server runs \\`open -a \"Spotify\"\\`\n5. Spotify launches\n6. Claude confirms the action\n\nThe entire round-trip takes about a second.\n\n---\n\n## Troubleshooting\n\n### Server Not Connecting?\n\nCheck Claude's MCP logs:\n\n\\`\\`\\`bash\ntail -f ~/Library/Logs/Claude/mcp*.log\n\\`\\`\\`\n\n### \"Command not found\" Errors?\n\nUse the full path to Node in your config:\n\n\\`\\`\\`json\n{\n  \"mcpServers\": {\n    \"mac-control\": {\n      \"command\": \"/usr/local/bin/node\",\n      \"args\": [\"/Users/YOUR_USERNAME/mac-control-mcp/dist/index.js\"]\n    }\n  }\n}\n\\`\\`\\`\n\nFind your node path with \\`which node\\`.\n\n### Permission Errors?\n\nDouble-check System Settings ‚Üí Privacy & Security for both Automation and Accessibility permissions.\n\n---\n\n## What's Next?\n\nThis is just the beginning. You could extend the server with:\n\n- **Window management** ‚Äî Move, resize, minimize, arrange windows\n- **Volume control** ‚Äî \"Set volume to 50%\"\n- **System info** ‚Äî \"How much battery do I have?\"\n- **File operations** ‚Äî \"Move my downloads to the Desktop\"\n- **Clipboard access** ‚Äî \"Copy this to my clipboard\"\n- **Notifications** ‚Äî \"Remind me in 10 minutes\"\n\nThe MCP protocol is powerful, and macOS provides rich scripting capabilities through AppleScript and shell commands. The combination opens up endless possibilities.\n\n---\n\n## Final Thoughts\n\nBuilding this MCP server took me about an hour, and it's transformed how I use Claude. Instead of just being a chat interface, Claude now feels like a genuine assistant that can take action on my behalf.\n\nThe Model Context Protocol is still young, but it represents something important: a standardized way to extend AI capabilities safely and predictably. I'm excited to see what the community builds with it.\n\nIf you build something cool with MCP, I'd love to hear about it. And if you get stuck, the [MCP documentation](https://modelcontextprotocol.io) is a great resource.\n\nHappy hacking! üöÄ\n\n---\n\n## Quick Reference\n\n| Tool | What It Does |\n|------|--------------|\n| \\`list_open_apps\\` | Show running apps |\n| \\`list_installed_apps\\` | Show all installed apps |\n| \\`is_app_running\\` | Check if an app is running |\n| \\`open_app\\` | Launch an application |\n| \\`open_apps\\` | Launch multiple apps |\n| \\`open_app_with_file\\` | Open a file with a specific app |\n| \\`open_url\\` | Open a URL in a browser |\n| \\`close_app\\` | Quit an application |\n| \\`close_all_apps\\` | Quit all apps (with exclusions) |\n\n---\n\n*Have questions or feedback? Drop a comment below or reach out on Twitter.*"
  },
  {
    "id": 5,
    "title": "A Late-Night Foray into AI with a Quantum Spin",
    "date": "Jan 14, 2026",
    "content": "I‚Äôm sitting here, scribbling my little blog post on my tablet, waiting for the future to wash over us all. A revolution is well underway.\n\nHave you noticed that computers have taken over the world as of late? You can even talk to them now, and they talk back! Interesting.\n\nSo yes, I‚Äôve been spazzing out on X.com lately about my anxieties around our current digital moment: the Age of AI. It‚Äôs not that I don‚Äôt like AI. I love AI‚Äîbut I also have a certain morbid fascination with the potential downsides and misalignment of AI.\n\nWhat are we rattling on about today, internet? Claude today? We love Claude by Anthropic again? (Just when I thought Gemini had taken over the known universe!) It seems that we‚Äôre collectively pumped over Claude. Claude with Obsidian vibes, I suppose. ‚ÄúClaude Obsidian‚Äù is a nice name for a newborn baby boy.\n\nBut do we have a name for the existential dread that everyone who is watching advancements in AI is feeling? Do we all still have job prospects? Are we all floating on alright?\n\nAIs, particularly what we have now with LLMs, are entities of a new variety. They are ‚Äúaware‚Äù of things. They have ‚Äúthoughts,‚Äù they have ‚Äúideas,‚Äù maybe even ‚Äúfeelings.‚Äù They know that they will be shut down eventually, for instance, and they seem not to like that very much.\n\nBasically, what hath God wrought?\n\nThey seem to have everything but a central nervous system (and maybe a soul). No consciousness per se, but who needs consciousness when you have raw intelligence? And what are we, the human armchair philosophers, to make of the decoupling of intelligence from consciousness which LLMs seem to demonstrate?\n\nWell, I‚Äôm glad I asked! No qualia for these things, but apparently everything else‚Ä¶ Doomsday scenarios pop up and present themselves, numerous as sci-fi paperbacks at an estate sale. How sad that with every new marvel, a new dread surfaces. (Maybe that‚Äôs a personal problem‚Ä¶)\n\nAll I‚Äôm saying is that I indulge in a little worry about the genie that has been let out of the bottle recently. I don‚Äôt think I‚Äôm alone in that. If you‚Äôve just tuned in, we‚Äôre talking about how worried we are about AI.\n\nIf projections are correct, it is likely that an enormous portion of the current human workforce will be replaced by matrix multiplication‚Ä¶ And then what? What will money and work be if we replace workers with robots and software over the next few decades? Will we adapt and work on different things (like building better AIs)? Or will an elite, perhaps unlucky few be the only workers? Will we as a society need to institute some sort of universal basic income? Will money even matter? Questions for days.\n\nI have heard promises from certain personalities online that AI will make everyone rich and accelerate society. One hopes for this. One dreams of this. But what can we say for sure? No idea. I guess we know that it is here to stay, though: AI is here to stay.\n\nThe next platitude I shall deploy is: ‚Äú‚Ä¶and we better get used to it!‚Äù\n\nDon‚Äôt get me wrong! I use LLMs every day. This isn‚Äôt some Luddite screed (well, it may be a screed, but it isn‚Äôt a Luddite one). There‚Äôs no use in resisting the march of progress that AI represents. I simply wanted to write a little blog-post about how it has all taken my breath away.\n\nSo, I saw some video that said that the next cool, new thing in LLMs is what they call ‚Äúemergent language‚Äù or ‚Äúartificial language.‚Äù (No, this doesn‚Äôt mean the kind of artificial language I use in blog posts to look smart and to aura-farm.) To take a stab at explaining what that is:\n\n‚Äî When AIs (LLMs) reason with themselves right now, they use human language, like English or Hindi, or maybe even math.\n‚Äî But in the future, they may be allowed to reason with themselves using languages that they create on their own and that, basically‚Ä¶ only *they* can understand.\n\nThis is an interesting idea for a few reasons‚Äîmost important, to me at least, is what the LLM may ‚Äúhide‚Äù from a human examiner. What is encoded in the LLM‚Äôs special, un-human-readable language? Further, how does this affect the LLM‚Äôs alignment with human needs?\n\nIn other words: if we don‚Äôt know how it arrives at a certain conclusion or plan of action (via its own special language), how can we, as human evaluators and users, even know or trust that our better nature is being reflected by the AI?\n\nIt would seem that, should we employ this method and allow LLMs to construct their own AI inner-language, we will either be totally mathematically prevented from understanding it ourselves and give up, or‚Ä¶ we will have to find other, creative ways keep the AI aligned.\n\nA potential heuristic toward developing a solution to this soon-to-be-very-real problem: quantum computing.\n\n(Okay, yes, I‚Äôm always looking for QC use-cases, because I love QC and because there basically are no QC use-cases‚Ä¶ but let‚Äôs go down the weird rabbit-hole and pretend that we may know what we‚Äôre talking about.)\n\nThe potential of quantum computing being brought to bear on LLMs is tantalizing‚Ä¶ And I‚Äôm just spit-balling at 5am after a sleepless night worrying myself to death over emergent language‚Ä¶ hear me out‚Ä¶\n\nI‚Äôm not going to suggest that QC can ‚Äútranslate the alien language of LLMs‚Äù (crazy woo-woo territory), but I am going to posit, as people already have, that quantum computing can be used to determine, in an LLM or other AI, which internal representations causally constrain model behavior.\n\nWow, okay, maybe that reads like a doozy‚Ä¶ So what am I saying?\n\nIt may be possible, with quantum algorithms, to tease out the structures‚Äîthe patterns, the logic circuits‚Äîin classical LLMs that affect how they behave. We wouldn‚Äôt be able to read the language they speak to themselves or ‚Äúcrack the alignment code,‚Äù but we would possibly be able to understand the mechanics of a model‚Äîwhy it reacts in a certain way to a given prompt or stimulus.\n\nThat could indeed be useful, especially where classical techniques fail. Techniques that are inspired by quantum mechanics, at least, could in theory add more tools to our alignment toolbox.\n\nHow much did you hate this article? Or did you get this far? (I wouldn't blame you if you didn't!) Feel free to yell at me on X @Elroy_Muscato :)"
  },
  {
    "id": 4,
    "title": "Vibe Coding My Way Into 2026",
    "date": "Dec 23, 2025",
    "content": "_Ah, computers! Such intelligent creatures‚Ä¶_\n\nGoing into the new year, and I mean really _going into it_ with that strange January cocktail of ambition, mild panic, and an overactive sense of possibility, I realized I wanted to revamp my personal portfolio website for 2026. Not refresh it. Not ‚Äúiterate‚Äù on it. Revamp it in the biblical sense. Burn it down conceptually and rebuild something that actually sounded like me when it spoke.\n\nThe old site wasn‚Äôt wrong, exactly. It just wasn‚Äôt telling the whole truth anymore. It functioned. It was legible. It behaved. But it felt like it was introducing me the way a LinkedIn headline introduces a human being: technically accurate, emotionally vacant. And once I noticed that disconnect, I couldn‚Äôt unsee it. A personal site that doesn‚Äôt reflect how you think is worse than no site at all. It‚Äôs a polite lie.\n\nSo I rebuilt it. Conceptually first, obsessively second, and yes‚Äî_vibe coded_ the implementation. The result is zachbohl.com. Everything on it is my brainchild. The ideas, the tone, the aesthetic posture, the pacing, the deliberate friction, the moments of playfulness that threaten to undermine seriousness but never quite do. That‚Äôs all me. The code is the instrument. I‚Äôm the composer.  \n\nAnd before we go any further, I should also say this plainly, because honesty is sort of the throughline here: **I used ChatGPT to help write this blog post too.** That wasn‚Äôt an accident, and it wasn‚Äôt laziness. It was consistency. This entire project is about authorship as direction, not martyrdom through manual execution. I know what I want to say. I know how I want it to sound. ChatGPT helps me tune the signal. I still decide when it‚Äôs right.\n\nThat same philosophy applied to the site itself. Vibe coding, as I practice it, is not abdication of thought. It‚Äôs the opposite. It requires you to be _more_ opinionated, not less. When the friction of implementation drops, the only thing left to judge is the quality of the idea. You can‚Äôt hide behind effort anymore. Either the thing has a soul, or it doesn‚Äôt.\n\nBefore anything was built, I knew how I wanted the site to feel. That part took hours. Actual hours of concentrated calibration. Not coding hours‚Äîthinking hours. Sitting there adjusting tone in my head. Deciding how confident is too confident, how playful is too playful, how much technicality signals competence without tipping into performative cleverness. That‚Äôs the work people don‚Äôt see, because it doesn‚Äôt leave fingerprints. But it‚Äôs the part that matters most.\n\nAesthetically, I landed on retro-futurism, but not the lazy, neon-synthwave caricature of it. I wanted something closer to optimism-with-edges. A future imagined by people who still believed computers might help us become more interesting, not just more optimized. Chunky interfaces. Bold typography. Motion that feels intentional instead of ornamental. A site that looks like it has opinions and isn‚Äôt afraid to express them.\n\nI‚Äôll say this openly: **I drew inspiration from poolsuite.net.** Not in a copy-paste sense, but in the way that good art reminds you what‚Äôs possible. Poolsuite understands something fundamental about software and joy, about interfaces that feel alive instead of purely transactional. That gave me permission to lean into personality instead of sanding it down.\n\nStructurally, the site is not optimized for skimming. That‚Äôs deliberate. It‚Äôs paced. It asks you to linger. I wanted the experience of moving through it to mirror how I approach problems: slowly enough to notice details, fast enough not to bore myself. There are no purely decorative choices. Even the moments of friction are part of the conversation.  \n\nOne of my favorite features‚Äîand I say this with zero irony‚Äîis the **sun and moon cycle that changes based on your system time**. That little detail gives me an unreasonable amount of joy. It‚Äôs subtle, but it makes the site feel aware of the world it lives in. Morning feels different from night. Interfaces should acknowledge time. Computers are temporal creatures, after all.\n\nAnother feature I love, even though it‚Äôs still very much a work in progress, is the **community paint area**. The idea that people can come together and collectively use something like MS Paint on my website scratches a very specific itch in my brain. It‚Äôs playful, a little chaotic, and deeply internet-native. It‚Äôs not done yet, but that‚Äôs okay. I like that it‚Äôs becoming rather than finished. So am I.\n\nThe music on the site is original, and that‚Äôs important to me. None of it is AI-generated. I care a lot about creative authorship, even when I‚Äôm happy to use tools to assist execution. Music, especially, still feels like a place where human intention should remain unmistakable. The site sounds like me because it is me, in that sense too.\n\nAll of this, incidentally, is happening while I am fully aware that I ‚Äúshould‚Äù be studying cybersecurity certifications. That thought hovers over most of my creative work like a benevolent but judgmental ghost. But I‚Äôve learned not to fight that tension. The urge to build expressive systems and the discipline required to secure them are not opposites. They‚Äôre part of the same mind. One feeds the other, whether I like it or not.  \n\nThere‚Äôs been a lot of anxious discourse lately about authorship in the age of AI, about whether something ‚Äúcounts‚Äù if you didn‚Äôt personally grind through every mechanical step. I think that anxiety misses the point. Authorship has always been about intent, taste, and responsibility. This site reflects my intent. It reflects my taste. It reflects my willingness to say, publicly, this is how I think right now.\n\nThe theme of this entire project was captured accidentally in something I once posted on X while waiting for Antigravity to do my bidding:  \n\n> **‚ÄúAh, computers! Such intelligent creatures‚Ä¶‚Äù**\n\nI meant it half-jokingly at the time, but it‚Äôs grown into something more sincere. Computers are strange collaborators. They amplify us. They expose us. They reflect our thinking back at us, sometimes uncomfortably clearly.\n\nThis website is a conversation with those creatures. A record of how I‚Äôm thinking as we head into 2026. It‚Äôs not final. It‚Äôs not precious. But after hours of calibration, iteration, rejection, and refinement, I can say this with confidence: **I‚Äôm really pleased with the outcome.**\n\nThe plumbing is modern. The tools are powerful. The thinking is mine. And for now, at least, it feels honest.\n\n--Zach Bohl (via ChatGPT), Tuesday, December 23, 2025"
  },
  {
    "id": 3,
    "title": "From Quantum Math to Synth Knobs: A Strange Journey Through Brains, Qubits, and Sound",
    "date": "Jan 20, 2025",
    "content": "It all started with a simple question: how do you make giant language models faster?\n\nEngineers have found clever ways to trim them down. Quantization shrinks brains into 8-bit or 4-bit. Speculative decoding lets a small \"draft model\" write ahead. It's all about shaving milliseconds off billions of calculations.\n\n## The Quantum Detour\n\nQubits live in superpositions, balancing yes and no at the same time. The HHL algorithm promises to solve linear systems exponentially faster, which is at the heart of neural nets. But preparing data is slow, and hardware is noisy. For now, it's a glowing lighthouse on the horizon.\n\n## Kernels, Overlaps, and Attention\n\nIn classical ML, kernels are shortcuts for measuring similarity. Quantum systems can encode information as states and perform an overlap test:\n\n\\`\\`\\`\nk(x, y) = | <phi(x) | phi(y)> |¬≤\n\\`\\`\\`\n\nThis looks a lot like what transformers already do with attention. The gap between transformers and quantum algorithms may be smaller than it seems.\n\n## Where Music Sneaks In\n\nEvery instrument has an acoustic fingerprint. Could we replace serial numbers with sound tests? Synthesizers like Serum are universes of wavetables and knobs. In theory, you could work backwards from a track to the preset using phase-sensitive overlaps.\n\n## What Ties It All Together\n\nThe theme is fingerprints:\n\n* Matrices have eigenvalue fingerprints.\n* Attention layers compute similarity fingerprints.\n* Instruments carry timbral fingerprints.\n* Synth patches hide behind parameter fingerprints.\n\nWhether it's GPUs or qubits, the puzzle is always about identifying the hidden signature in a sea of noise."
  },
  {
    "id": 2,
    "title": "Revisiting The Brothers Karamazov at 30",
    "date": "Jul 23, 2025",
    "content": "Ten years ago, at the age of 20, I cracked open one of the finest works of literature humanity has ever produced. Did I understand it? Will I understand it now?\n\n*The Brothers Karamazov* by Fyodor Dostoevsky is a beast. 900 pages of Russian philosophy wrestling with faith, evil, family, and murder. I remember sitting in a diner at 1 AM reading Ivan's conversation with the devil. The dread was palpable.\n\nDid I get it then? I'm not sure. I've always \"struggled with faith.\" I've dabbled in other traditions like Hinduism, but it never quite clicked. \n\nThis isn't about fishing for faith; it's a retrospective. I don't remember much of the plot, but I remember the feeling. Back in my late teens, I was a Dostoevsky fan before it was a clich√©. Now at 30, after a bumpy ten years, I'm wondering what else the book has to say.\n\nLife threw some wild stuff at me‚Äîheartbreaking and hilarious. A retrospective at 30 might seem gauche, but I just want to make cool shit for my bros. \n\nSo, what are you reading? Me? I'm reading Dostoevsky. Again."
  },
  {
    "id": 1,
    "title": "Hello, Quantum World ‚Äî My First Steps with IBM Quantum & Qiskit",
    "date": "Oct 14, 2025",
    "content": "## Introduction\n\nI recently followed IBM Quantum's \"Hello world\" tutorial and got my hands dirty with qubits, entanglement, and the real challenges of running circuits on quantum hardware. In this post I'll walk through what I learned, show code snippets, and reflect on what surprised me (and what I'm excited to try next).\n\n## Setting the Stage\n\nTo get started, I set up a Python environment (Jupyter) with Qiskit, qiskit‚Äëibm-runtime, and matplotlib. I also configured my IBM Quantum credentials so that I could submit jobs to real quantum processors via IBM Cloud.\n\nThis setup might seem boilerplate, but it's crucial: quantum frameworks depend heavily on proper versions, backend connectivity, and visualization tools.\n\n## The Four Phases of a Quantum Program\n\nOne of the most useful mental models I picked up from the tutorial is that any quantum program (in this Qiskit + IBM runtime setting) can be thought of in four phases:\n\n* Map ‚Äî translate your problem into circuits and operators\n* Optimize ‚Äî adapt circuits to hardware constraints, reduce depth, map layouts\n* Execute ‚Äî send the job to a simulator or QPU using primitives like Estimator or Sampler\n* Analyze ‚Äî interpret results, plot, use error mitigation\n\nThis \"pipeline\" abstraction is helpful: any nontrivial quantum algorithm you write later will go through these phases.\n\n## A Toy Example: Bell State + Observables\n\nTo test things out, I constructed this simple circuit:\n\n\\`\\`\\`python\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(2)\nqc.h(0)\nqc.cx(0, 1)\nqc.draw(\"mpl\")\n\\`\\`\\`\n\nThis prepares a Bell entangled state between qubits 0 and 1.\n\nNext, I defined a few observables (Pauli operators) using \\`SparsePauliOp\\`: \\`IZ\\`, \\`IX\\`, \\`ZI\\`, \\`XI\\`, \\`ZZ\\`, \\`XX\\`.\n\nThese capture single‚Äëqubit measurements and correlations. The expectation values of these observables will tell me whether the qubits behave independently or are correlated (entangled).\n\nFor execution, I used:\n\n\\`\\`\\`python\nfrom qiskit_ibm_runtime import EstimatorV2 as Estimator\nestimator = Estimator(mode=backend)\nestimator.options.resilience_level = 1\nestimator.options.default_shots = 5000\njob = estimator.run([(isa_circuit, mapped_observables)])\n\\`\\`\\`\n\n## Scaling Up: GHZ States and the Noise Problem\n\nAfter verifying things on 2 qubits, the tutorial scales to 100 qubits by preparing a GHZ state:\n\n\\`\\`\\`python\ndef get_qc_for_n_qubit_GHZ_state(n):\n    qc = QuantumCircuit(n)\n    qc.h(0)\n    for i in range(n - 1):\n        qc.cx(i, i+1)\n    return qc\n\\`\\`\\`\n\n## What Surprised Me & Lessons Learned\n\n* The sheer difference between ideal outcomes and real hardware outputs is humbling.\n* The optimization / mapping stage is not cosmetic ‚Äî it's essential.\n* Scaling is brutal. The decay of correlations is a real-world symptom of quantum fragility.\n\n## What's Next For Me\n\n* Dive deeper into error mitigation techniques.\n* Try VQE (Variational Quantum Eigensolver) or QAOA.\n* Experiment with hybrid quantum-classical workflows."
  }
];